# Паттерн Proxy
___
# Проблема
___
    Необходимо контролировать доступ к объекту, не изменяя при этом поведение клиента.
___

# Описание

___
При проектировании сложных систем, достаточно часто возникает необходимость обеспечить контролируемый доступ к определенным объектам системы. Мотивацией для этого служит ряд приобретаемых преимуществ. Таких как, ленивая инициализация по требованию для «громоздких» объектов, подсчет количества ссылок на объект и т.д. и т.п. Однако, не всегда потребность в контролируемом доступе к объекту базируется только на преимуществах. Как правило, сложность процессов реального мира, ограничения вычислительных ресурсов просто не оставляют проектировщику выбора, нежели как воспользоваться паттерном «Заместитель» («Сурогат»).


Идея паттерна «Заместитель» заключается в предоставлении клиенту другого объекта (заместителя), взамен объекту с контролируемым доступом. При этом, объект-заместитель, реализует тот-же интерфейс, что и оригинальный объект, в результате чего, поведение клиента не требует изменений. Иными словами, клиент взаимодействует с заместителем ровно как с оригинальным объектом посредством единого интерфейса. Клиент, так же, не делает предположений о том работает ли он с реальным объектом или его заместителем. Контролирование доступа к объекту, при этом, достигается за счет использования ссылки на него в заместителе, благодаря которой заместитель переадресовывает внешние вызовы контролируемому объекту, возможно сопровождая их дополнительными операциями.


Такой подход позволяет неявным для клиента образом контролировать доступ к объекту.

---

## Пример

---

В качестве примера, мы создали программу, 
которая предоставляет непрямой доступ к удаленно-лежащему проекту, в нашем случае на GitHub.

Proxy.RealProject имплементирует интерфейс Proxy.Project, который содержит в себе метод run, без реализации.
В самом же методе: поле url - ссылка на проект; конструктор Proxy.RealProject, который принимает url; метод load - скачивает проект пользователю.

    public class Proxy.RealProject implements Proxy.Project{

        private String url;

        public Proxy.RealProject(String url){
            this.url = url;
            load();
        }

        public void load(){
            System.out.println("Loading project from " + url + "...");
        }

        @Override
        public void run() {
            System.out.println("Running project " + url + "...");
        }
    }

Нас больше интересует класс Proxy.ProxyProject. Он также имплементирует интерфейс Proxy.Project, но его реализация метода run отличается.
Мы наблюдаем проверку на наличие экземпляра класса Proxy.RealProject, если его нет, то создаем. Далее вызываем run на realProject. То есть, мы запускаем процессы класса Proxy.RealProject, через класс Proxy.ProxyProject.

    public class Proxy.ProxyProject implements Proxy.Project{
        private  String url;
        private Proxy.RealProject realProject;

        public  Proxy.ProxyProject(String url) {
            this.url = url;
        }

        @Override
        public void run() {
            if (realProject == null){
                realProject = new Proxy.RealProject(url);
            }
            realProject.run();
        }
    }